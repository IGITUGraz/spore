<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SPORE: spore::DiligentConnectorModel&lt; ConnectionT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEST module SPORE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacespore.html">spore</a></li><li class="navelem"><a class="el" href="classspore_1_1DiligentConnectorModel.html">DiligentConnectorModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classspore_1_1DiligentConnectorModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spore::DiligentConnectorModel&lt; ConnectionT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Connector model for diligent connections.  
 <a href="classspore_1_1DiligentConnectorModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="diligent__connector__model_8h_source.html">diligent_connector_model.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spore::DiligentConnectorModel&lt; ConnectionT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classspore_1_1DiligentConnectorModel__inherit__graph.png" border="0" usemap="#spore_1_1DiligentConnectorModel_3_01ConnectionT_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for spore::DiligentConnectorModel&lt; ConnectionT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classspore_1_1DiligentConnectorModel__coll__graph.png" border="0" usemap="#spore_1_1DiligentConnectorModel_3_01ConnectionT_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5265a2fb87f9b8aea17f866f665c13f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#ae5265a2fb87f9b8aea17f866f665c13f">DiligentConnectorModel</a> (const std::string name, bool is_primary=true, bool has_delay=true, bool requires_symmetric=false)</td></tr>
<tr class="separator:ae5265a2fb87f9b8aea17f866f665c13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e384af8064a0d597950a690f1b71fdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a7e384af8064a0d597950a690f1b71fdc">DiligentConnectorModel</a> (const <a class="el" href="classspore_1_1DiligentConnectorModel.html">DiligentConnectorModel</a> &amp;other, const std::string name)</td></tr>
<tr class="separator:a7e384af8064a0d597950a690f1b71fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64525cb6a032a76e65571121386182a2"><td class="memItemLeft" align="right" valign="top">virtual nest::ConnectorBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a64525cb6a032a76e65571121386182a2">add_connection</a> (nest::Node &amp;src, nest::Node &amp;tgt, nest::ConnectorBase *conn, nest::synindex syn_id, double weight, double delay)</td></tr>
<tr class="separator:a64525cb6a032a76e65571121386182a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af052a1b0ce88c20b1f60b21233b02dc3"><td class="memItemLeft" align="right" valign="top">virtual nest::ConnectorBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#af052a1b0ce88c20b1f60b21233b02dc3">add_connection</a> (nest::Node &amp;src, nest::Node &amp;tgt, nest::ConnectorBase *conn, nest::synindex syn_id, DictionaryDatum &amp;d, double weight, double delay)</td></tr>
<tr class="separator:af052a1b0ce88c20b1f60b21233b02dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c226761837be3e78fe8a3166ec9a4f"><td class="memItemLeft" align="right" valign="top">virtual nest::ConnectorBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#ac3c226761837be3e78fe8a3166ec9a4f">delete_connection</a> (nest::Node &amp;tgt, size_t target_thread, nest::ConnectorBase *conn, nest::synindex syn_id)</td></tr>
<tr class="separator:ac3c226761837be3e78fe8a3166ec9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755c00649a59daa8c836e4ac29eefdff"><td class="memItemLeft" align="right" valign="top">virtual nest::ConnectorModel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a755c00649a59daa8c836e4ac29eefdff">clone</a> (std::string name) const </td></tr>
<tr class="separator:a755c00649a59daa8c836e4ac29eefdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a22867e58e2138643ce608e3758c751db"><td class="memItemLeft" align="right" valign="top">nest::ConnectorBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a22867e58e2138643ce608e3758c751db">cleanup_delete_connection</a> (nest::Node &amp;tgt, size_t target_thread, nest::ConnectorBase *conn, nest::synindex syn_id)</td></tr>
<tr class="memdesc:a22867e58e2138643ce608e3758c751db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup and delete the given connection.  <a href="#a22867e58e2138643ce608e3758c751db">More...</a><br /></td></tr>
<tr class="separator:a22867e58e2138643ce608e3758c751db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7fc76ac899bcab0c9dd7da26ac6126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a1b7fc76ac899bcab0c9dd7da26ac6126">register_connector</a> (nest::ConnectorBase *new_conn, nest::ConnectorBase *old_conn, nest::index sender_gid, size_t target_thread, nest::synindex syn_id)</td></tr>
<tr class="separator:a1b7fc76ac899bcab0c9dd7da26ac6126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fa9543674ee66ffbedd54008803e76"><td class="memItemLeft" align="right" valign="top">nest::ConnectorBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspore_1_1DiligentConnectorModel.html#a07fa9543674ee66ffbedd54008803e76">get_hom_connector</a> (nest::ConnectorBase *conn, nest::synindex syn_id)</td></tr>
<tr class="separator:a07fa9543674ee66ffbedd54008803e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ConnectionT&gt;<br />
class spore::DiligentConnectorModel&lt; ConnectionT &gt;</h3>

<p>Connector model for diligent connections. </p>
<p>Generic connector model for connections that require being updated on a regular time grid. Use the function <a class="el" href="namespacespore.html#a4417a3a2a5669ff63832b034fc08d56f">spore::register_diligent_connection_model</a> provided in <a class="el" href="diligent__connector__model_8h_source.html">diligent_connector_model.h</a>, to register your synapse model at the network, to use the diligent synapse model instead of NEST's build-in synapse model.</p>
<p>Diligent connections are connection models that are updated on a regular time grid (as opposed to NEST's standard lazy update). More precisely, the API guarantees that the <em>send</em> function of the synapse is called at least once in a certain time window. If no presynaptic spike is send via the synapse during that time, a "dummy" spike is inserted to trigger a synapse update. The synapse can distinguish between "dummy" spikes and "real" spikes through the receptor port, which is set to the invalid value of -1 for dummy spikes (see <a class="el" href="classspore_1_1SynapseUpdateEvent.html" title="The dummy event class used to trigger synapse updates. ">SynapseUpdateEvent</a>).</p>
<p>The length of the update time window can be controlled using the InitSynapseUpdater SLI function. It takes two arguments, the update interval and the maximum synaptic update latency. Both are tuning parameters that can be used to optimize the simulation performance. Long update intervals are likely more time efficient, but require more memory.</p>
<p>The <a class="el" href="classspore_1_1DiligentConnectorModel.html" title="Connector model for diligent connections. ">DiligentConnectorModel</a> provides the interface this mechanism. New synapse models that use the diligent connection framework should be registered using the register_diligent_connection_model template function. Connections instantiated from this model will be automatically registered at the global <a class="el" href="classspore_1_1ConnectionUpdateManager.html" title="Class that manages updating diligent synapses. ">ConnectionUpdateManager</a> object that takes care of triggering the synapse updates.</p>
<p>Synapses registered with the <a class="el" href="classspore_1_1DiligentConnectorModel.html" title="Connector model for diligent connections. ">DiligentConnectorModel</a> must implement a method called <em>is_degenerated</em> that takes no arguments and returns a <code>bool</code>. This is used by the garbage collector of the <a class="el" href="classspore_1_1ConnectionUpdateManager.html" title="Class that manages updating diligent synapses. ">ConnectionUpdateManager</a> to identify synapses that need to be deleted. The mechanism is described in detail in the documentation of <a class="el" href="classspore_1_1ConnectionUpdateManager.html" title="Class that manages updating diligent synapses. ">ConnectionUpdateManager</a>.</p>
<p>Another difference of diligent connectors is that the calibrate function of their CommonSynapseProperties object is called additionally on simulation startup (such as nest::Node objects).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classspore_1_1ConnectionUpdateManager.html" title="Class that manages updating diligent synapses. ">ConnectionUpdateManager</a>, <a class="el" href="classspore_1_1SynapseUpdateEvent.html" title="The dummy event class used to trigger synapse updates. ">SynapseUpdateEvent</a>, <a class="el" href="classspore_1_1SynapticSamplingRewardGradientConnection.html" title="Reward-based synaptic sampling connection class. ">SynapticSamplingRewardGradientConnection</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5265a2fb87f9b8aea17f866f665c13f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::<a class="el" href="classspore_1_1DiligentConnectorModel.html">DiligentConnectorModel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_primary</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_delay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a7e384af8064a0d597950a690f1b71fdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::<a class="el" href="classspore_1_1DiligentConnectorModel.html">DiligentConnectorModel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classspore_1_1DiligentConnectorModel.html">DiligentConnectorModel</a>&lt; ConnectionT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a64525cb6a032a76e65571121386182a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorBase * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::add_connection </td>
          <td>(</td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new connection between two nodes.</p>
<p>Delay and weight have the default value NAN. NAN is a special value in cmath, which describes double values that are not a number. If delay or weight is omitted in an add_connection call, NAN indicates this and weight/delay are set only, if they are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>source node. </td></tr>
    <tr><td class="paramname">tgt</td><td>target node. </td></tr>
    <tr><td class="paramname">target_thread</td><td>thread of the target. </td></tr>
    <tr><td class="paramname">conn</td><td>Connector Base from where the connection will be deleted. </td></tr>
    <tr><td class="paramname">syn_id</td><td>Synapse type. </td></tr>
    <tr><td class="paramname">delay</td><td>synaptic delay. </td></tr>
    <tr><td class="paramname">weight</td><td>synaptic weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Connector, with the inserted new connection. </dd></dl>

</div>
</div>
<a class="anchor" id="af052a1b0ce88c20b1f60b21233b02dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorBase * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::add_connection </td>
          <td>(</td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryDatum &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new connection between two nodes.</p>
<p>Delay and weight have the default value NAN. NAN is a special value in cmath, which describes double values that are not a number. If delay or weight is omitted in an add_connection call, NAN indicates this and weight/delay are set only, if they are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>source node. </td></tr>
    <tr><td class="paramname">tgt</td><td>target node. </td></tr>
    <tr><td class="paramname">target_thread</td><td>thread of the target. </td></tr>
    <tr><td class="paramname">conn</td><td>Connector Base from where the connection will be deleted. </td></tr>
    <tr><td class="paramname">syn_id</td><td>Synapse type. </td></tr>
    <tr><td class="paramname">p</td><td>dictionary with synapse paramters. </td></tr>
    <tr><td class="paramname">delay</td><td>synaptic delay. </td></tr>
    <tr><td class="paramname">weight</td><td>synaptic weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Connector, with the inserted new connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a22867e58e2138643ce608e3758c751db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorBase * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::cleanup_delete_connection </td>
          <td>(</td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleanup and delete the given connection. </p>
<p>This deviates from the standard NEST implementation only in that it preferably deletes synapses that are marked for deletion instead of taking the first synapse that matches the specifications. Synapses indicate that are marked for deletion by returning true from their <code>is_degenerated()</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>Target node </td></tr>
    <tr><td class="paramname">target_thread</td><td>Thread of the target </td></tr>
    <tr><td class="paramname">conn</td><td>Connector Base from where the connection will be deleted </td></tr>
    <tr><td class="paramname">syn_id</td><td>Synapse type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Connector, equal to the original but with an erased connection to the defined target. </dd></dl>

</div>
</div>
<a class="anchor" id="a755c00649a59daa8c836e4ac29eefdff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorModel * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a clone of the connector model. </p>

</div>
</div>
<a class="anchor" id="ac3c226761837be3e78fe8a3166ec9a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorBase * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::delete_connection </td>
          <td>(</td>
          <td class="paramtype">nest::Node &amp;&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a connection of a given type directed to a defined target Node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>Target node </td></tr>
    <tr><td class="paramname">target_thread</td><td>Thread of the target </td></tr>
    <tr><td class="paramname">conn</td><td>Connector Base from where the connection will be deleted </td></tr>
    <tr><td class="paramname">syn_id</td><td>Synapse type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new Connector, equal to the original but with an erased connection to the defined target. </dd></dl>

</div>
</div>
<a class="anchor" id="a07fa9543674ee66ffbedd54008803e76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nest::ConnectorBase * <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::get_hom_connector </td>
          <td>(</td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to extract the homogeneous connector with given type from a given connector. If the given connector is homogeneous the type is checked and it is returned. If the type does not match the function fails. If the connector is heterogeneous a connector of given is searched within it and returned if found. Returns 0 if a 0-pointer is passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>the connector to be checked, can be 0. </td></tr>
    <tr><td class="paramname">syn_id</td><td>the type id of the connector to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the homogeneous connector, 0 if none found. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b7fc76ac899bcab0c9dd7da26ac6126"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classspore_1_1DiligentConnectorModel.html">spore::DiligentConnectorModel</a>&lt; ConnectionT &gt;::register_connector </td>
          <td>(</td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>new_conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::ConnectorBase *&#160;</td>
          <td class="paramname"><em>old_conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::index&#160;</td>
          <td class="paramname"><em>sender_gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nest::synindex&#160;</td>
          <td class="paramname"><em>syn_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers the connector at the <a class="el" href="classspore_1_1ConnectionUpdateManager.html" title="Class that manages updating diligent synapses. ">ConnectionUpdateManager</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="diligent__connector__model_8h_source.html">diligent_connector_model.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 13 2017 20:24:04 for SPORE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
